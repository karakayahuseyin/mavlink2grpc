/**
 * Copyright (C) 2025 HÃ¼seyin Karakaya
 * This file is part of the mavlink2grpc project licensed under the MIT License.
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated from MAVLink message definitions
 */

#include "MessageConverter.h"
#include <iostream>

namespace mav2grpc {

uint64_t MessageConverter::get_timestamp_usec() {
  auto now = std::chrono::system_clock::now();
  auto duration = now.time_since_epoch();
  return std::chrono::duration_cast<std::chrono::microseconds>(duration).count();
}

std::optional<mavlink::MavlinkMessage> 
MessageConverter::to_proto(const mavlink_message_t& mavlink_msg,
                           std::optional<uint64_t> timestamp_usec) {
  mavlink::MavlinkMessage proto_msg;

  // Set header fields
  proto_msg.set_system_id(mavlink_msg.sysid);
  proto_msg.set_component_id(mavlink_msg.compid);
  proto_msg.set_message_id(mavlink_msg.msgid);
  proto_msg.set_timestamp_usec(timestamp_usec.value_or(get_timestamp_usec()));

  // Convert based on message ID
  switch (mavlink_msg.msgid) {
{% for msg in messages %}
    case MAVLINK_MSG_ID_{{ msg.name|upper }}:
      convert_{{ msg.name|lower }}_to_proto(mavlink_msg, proto_msg);
      return proto_msg;
{% endfor %}

    default:
      std::cerr << "Unsupported MAVLink message ID: " << mavlink_msg.msgid << "\n";
      return std::nullopt;
  }
}

std::optional<mavlink_message_t>
MessageConverter::from_proto(const mavlink::MavlinkMessage& proto_msg,
                             uint8_t system_id,
                             uint8_t component_id) {
  mavlink_message_t mavlink_msg;

  // Handle different payload types
  switch (proto_msg.payload_case()) {
{% for msg in messages %}
    case mavlink::MavlinkMessage::k{{ sanitize_message_name(msg.name) }}:
      if (convert_{{ msg.name|lower }}_from_proto(
            proto_msg.{{ msg.name|lower }}(), 
            mavlink_msg, 
            system_id, 
            component_id)) {
        return mavlink_msg;
      }
      return std::nullopt;
{% endfor %}

    case mavlink::MavlinkMessage::PAYLOAD_NOT_SET:
      std::cerr << "Proto message has no payload set\n";
      return std::nullopt;

    default:
      std::cerr << "Unsupported proto payload type: " << proto_msg.payload_case() << "\n";
      return std::nullopt;
  }
}

{% for msg in messages %}
// ============================================================================
// {{ msg.name|upper }} (ID: {{ msg.id }})
// ============================================================================

void MessageConverter::convert_{{ msg.name|lower }}_to_proto(
    const mavlink_message_t& mavlink_msg,
    mavlink::MavlinkMessage& proto_msg) {
  
  // Decode MAVLink message
  mavlink_{{ msg.name|lower }}_t mavlink_data;
  mavlink_msg_{{ msg.name|lower }}_decode(&mavlink_msg, &mavlink_data);

  // Create proto message
  auto* proto = proto_msg.mutable_{{ msg.name|lower }}();

  // Convert fields
{% for field in msg.fields %}
{% if field.is_array %}
{% if field.base_type == 'char' %}
  // String field: {{ field.name }}
  proto->set_{{ sanitize_field_name(field.name) }}(
    std::string(mavlink_data.{{ field.name }}, 
                strnlen(mavlink_data.{{ field.name }}, {{ field.array_length }})));
{% else %}
  // Array field: {{ field.name }}
  for (size_t i = 0; i < {{ field.array_length }}; ++i) {
{% if field.type_info.is_enum %}
    proto->add_{{ sanitize_field_name(field.name) }}(
      static_cast<mavlink::{{ msg.dialect }}::{{ field.type_info.proto_type }}>(
        mavlink_data.{{ field.name }}[i]));
{% else %}
    proto->add_{{ sanitize_field_name(field.name) }}(mavlink_data.{{ field.name }}[i]);
{% endif %}
  }
{% endif %}
{% else %}
  // Scalar field: {{ field.name }}
{% if field.type_info.is_enum %}
  proto->set_{{ sanitize_field_name(field.name) }}(
    static_cast<mavlink::{{ msg.dialect }}::{{ field.type_info.proto_type }}>(
      mavlink_data.{{ field.name }}));
{% else %}
  proto->set_{{ sanitize_field_name(field.name) }}(mavlink_data.{{ field.name }});
{% endif %}
{% endif %}
{% endfor %}
}

bool MessageConverter::convert_{{ msg.name|lower }}_from_proto(
    const mavlink::{{ msg.dialect }}::{{ sanitize_message_name(msg.name) }}& proto,
    mavlink_message_t& mavlink_msg,
    uint8_t system_id,
    uint8_t component_id) {
  
{% set scalar_fields = [] %}
{% for field in msg.fields %}
{% if not field.is_array and field.type != 'uint8_t_mavlink_version' %}
{% set _ = scalar_fields.append(field) %}
{% endif %}
{% endfor %}
  // Pack MAVLink message
  mavlink_msg_{{ msg.name|lower }}_pack(
    system_id,
    component_id,
    &mavlink_msg
{% for field in scalar_fields %}
{% if field.type_info.is_enum %}
    , static_cast<uint8_t>(proto.{{ sanitize_field_name(field.name) }}())
{% else %}
    , proto.{{ sanitize_field_name(field.name) }}()
{% endif %}
{% endfor %}
  );

  return true;
}

{% endfor %}

} // namespace mav2grpc
